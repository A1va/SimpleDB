package simpledb;

import java.util.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends Operator {

    private static final long serialVersionUID = 1L;

    private JoinPredicate joinPredicate;

    private TupleDesc td;

    private DbIterator child1, child2;

    //记录了当前遍历到的左表的tuple，为了在下一次的方法调用时保留上一次遍历到的值，只能是实例变量而不能是方法内局部变量
    private Tuple left;

    /**
     * Constructor. Accepts to children to join and the predicate to join them
     * on
     *
     * @param p      The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
        // some code goes here
        joinPredicate = p;
        this.child1 = child1;
        this.child2 = child2;
        int length1 = child1.getTupleDesc().numFields();
        int length2 = child2.getTupleDesc().numFields();
        Type[] types = new Type[length1 + length2];
        String[] names = new String[types.length];
        //得到新表的tupleDesc(行描述)的types和names
        for (int i = 0; i < length1; i++) {
            types[i] = child1.getTupleDesc().getFieldType(i);
            names[i] = child1.getTupleDesc().getFieldName(i);
        }
        for (int i = 0; i < length2; i++) {
            types[i + length1] = child2.getTupleDesc().getFieldType(i);
            names[i + length1] = child2.getTupleDesc().getFieldName(i);
        }
        td = new TupleDesc(types, names);
    }

    public JoinPredicate getJoinPredicate() {
        // some code goes here
        return joinPredicate;
    }

    /**
     * @return the field name of join field1. Should be quantified by
     * alias or table name.
     * 这两个方法直接用getFieldName即可，而不必处理alias，这是因为在SeqScan中处理了
     * 而其他操作符是直接或间接以其来构造的(我的理解是每次都要先全表扫描一遍)todo 如果这里理解不对再回来修改想法
     * 他们的getTupleDesc().getFieldName最终会返回在SeqScan中得到的fieldName
     */
    public String getJoinField1Name() {
        // some code goes here
        return child1.getTupleDesc().getFieldName(joinPredicate.getIndex1());
    }

    /**
     * @return the field name of join field2. Should be quantified by
     * alias or table name.
     */
    public String getJoinField2Name() {
        // some code goes here
        return child2.getTupleDesc().getFieldName(joinPredicate.getIndex2());
    }

    /**
     * @see simpledb.TupleDesc#merge(TupleDesc, TupleDesc) for possible
     * implementation logic.
     */
    public TupleDesc getTupleDesc() {
        // some code goes here
        return td;
    }

    public void open() throws DbException, NoSuchElementException,
            TransactionAbortedException {
        // some code goes here
        child1.open();
        child2.open();
        super.open();
    }

    public void close() {
        // some code goes here
        super.close();
        child1.close();
        child2.close();
    }

    public void rewind() throws DbException, TransactionAbortedException {
        // some code goes here
        child1.rewind();
        child2.rewind();
        left = null;
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no
     * more tuples. Logically, this is the next tuple in r1 cross r2 that
     * satisfies the join predicate. There are many possible implementations;
     * the simplest is a nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of Join
     * are simply the concatenation(串联，连结) of joining tuples from the left and right
     * relation. Therefore, if an equality predicate is used there will be two
     * copies of the join attribute in the results. (Removing such duplicate
     * columns can be done with an additional projection operator if needed.)
     * todo 什么意思？？？
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple fetchNext() throws TransactionAbortedException, DbException {
        // some code goes here
        // TODO: 17-5-29 改善嵌套循环

        int length1 = child1.getTupleDesc().numFields();
        while (child1.hasNext() || child2.hasNext()) {
            if (left == null || !child2.hasNext()) {
                // left == null代表还没初始化过，因此要调用next给它赋值
                // !child2.hasNext() 代表child2表已经遍历完一遍了，这时候需要重新调用next给left赋值
                // 并将child2重新初始化，对新的left重新遍历一遍child2
                // 也就是说，如果child2还没遍历完，left还不能更新，这是因为有可能child1的一行对应child2的几行
                left = child1.next();
                child2.rewind();
            }
            //每个child1的tuple对应child2的一次完整遍历，复杂度为O(n1 * n2)
            while (child2.hasNext()) {
                Tuple result = new Tuple(td);
                //应该不用下面这行，因为RecordId对这些处理后的tuple来说没有意义
                //result.setRecordId(left.getRecordId());
                Tuple right = child2.next();
                if (joinPredicate.filter(left, right)) {
                    for (int i = 0; i < length1; i++) {
                        result.setField(i, left.getField(i));
                    }
                    for (int i = 0; i < child2.getTupleDesc().numFields(); i++) {
                        result.setField(i + length1, right.getField(i));
                    }
                    return result;
                }
            }
        }
        return null;
    }

    @Override
    public DbIterator[] getChildren() {
        // some code goes here
        return new DbIterator[]{this.child1, this.child2};
    }

    @Override
    public void setChildren(DbIterator[] children) {
        // some code goes here
        this.child1 = children[0];
        this.child2 = children[1];
    }

}
